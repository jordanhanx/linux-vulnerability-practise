#include <atomic>
#include <chrono>
#include <cmath>
#include <condition_variable>
#include <cstdlib>
#include <fstream>
#include <iostream>
#include <mutex>
#include <openssl/sha.h>
#include <string>
#include <thread>
#include <vector>

#include "progressbar.hpp"

std::mutex mtx;
std::atomic<size_t> counter(0);
std::atomic<bool> hackFlag(false);
std::condition_variable cv;

std::vector<char> genDictionary() {
  std::vector<char> chars;
  for (char i = 'a'; i <= 'z'; ++i) {
    chars.push_back(i);
  }
  for (char i = 'A'; i <= 'Z'; ++i) {
    chars.push_back(i);
  }
  for (char i = '0'; i <= '9'; ++i) {
    chars.push_back(i);
  }
  return chars;
}

std::string tryOneSHA256(const std::string &pswd) {
  // use openssl calculate SHA-256
  unsigned char hashBuf[SHA256_DIGEST_LENGTH];
  SHA256((unsigned char *)pswd.data(), pswd.size(), hashBuf);
  // convert hash value into string
  std::string hashCode(2 * SHA256_DIGEST_LENGTH, ' ');
  static const char hexChars[] = "0123456789abcdef";
  for (int i = 0; i < SHA256_DIGEST_LENGTH; i++) {
    hashCode[2 * i] = hexChars[(unsigned int)hashBuf[i] >> 4];
    hashCode[2 * i + 1] = hexChars[(unsigned int)hashBuf[i] & 0x0F];
  }
  return hashCode;
}

void tryHashInGroup(std::string &pswd, const std::string &hashcode,
                    const std::vector<char> &dict, int32_t pswdLen,
                    size_t beginIdx, size_t endIdx) {
  for (size_t idx = beginIdx; idx < endIdx; ++idx) {
    std::string tryPswd(pswdLen, '\0');
    int32_t quotient = idx;
    for (int32_t pos = pswdLen - 1; pos >= 0; --pos) {
      tryPswd[pos] = dict[quotient % dict.size()];
      quotient = quotient / dict.size();
    }
    std::string encrypted = tryOneSHA256(tryPswd);
    ++counter;
    if (hackFlag) {
      break;
    }
    if (hashcode == encrypted) {
      hackFlag = true;
      pswd = std::string(tryPswd);
      // std::cout << "thread(" << std::this_thread::get_id()
      //           << ") hack the password!\n";
      break;
    }
  }
}

int main(int agrc, char **argv) {
  if (agrc != 4) {
    std::cout
        << "Usage: ./decrypt-hash <threads> <passwordlength> <hashcode>\n";
    return EXIT_FAILURE;
  }
  // init
  std::string hashcode(argv[3]);
  std::vector<char> dict = genDictionary();
  std::string pswd;
  int num = std::stoi(argv[1]);
  int pswdLen = std::stoi(argv[2]);
  size_t totalSize = std::pow(dict.size(), pswdLen);
  size_t groupSize = totalSize / num;
  // threads pool
  std::vector<std::thread> thr_pool(num);
  for (size_t i = 0; i < thr_pool.size(); ++i) {
    thr_pool[i] = std::thread(tryHashInGroup, std::ref(pswd),
                              std::ref(hashcode), std::ref(dict), pswdLen,
                              i * groupSize, (i + 1) * groupSize);
    thr_pool[i].detach();
  }
  // main thread wait and display
  std::unique_lock<std::mutex> lck(mtx);
  progressbar bar;
  while (!hackFlag && counter < totalSize) {
    bar.display(100 * counter / totalSize);
    cv.wait_for(lck, std::chrono::milliseconds(500));
  }
  std::cout << "\npassword is [" << pswd << "]\n";

  return EXIT_SUCCESS;
}