#include <atomic>
#include <chrono>
#include <cmath>
#include <condition_variable>
#include <cstdlib>
#include <fstream>
#include <iostream>
#include <mutex>
#include <openssl/sha.h>
#include <string>
#include <thread>
#include <vector>

#include "progressbar.hpp"

std::atomic<size_t> counter(0);    // count the finished jobs
std::atomic<size_t> aliveThrs(0);  // count the working threads
std::atomic<bool> hackFlag(false); // true if the flag hack is successful

// build a dictionary including all password characters
std::vector<char> genDictionary() {
  std::vector<char> chars;
  for (char i = 'a'; i <= 'z'; ++i) {
    chars.push_back(i);
  }
  for (char i = 'A'; i <= 'Z'; ++i) {
    chars.push_back(i);
  }
  for (char i = '0'; i <= '9'; ++i) {
    chars.push_back(i);
  }
  return chars;
}

// hash one string
std::string tryOneSHA256(const std::string &pswd) {
  // use openssl calculate SHA-256
  unsigned char hashBuf[SHA256_DIGEST_LENGTH];
  SHA256((unsigned char *)pswd.data(), pswd.size(), hashBuf);
  // convert hash value into string
  std::string hashCode(2 * SHA256_DIGEST_LENGTH, ' ');
  static const char hexChars[] = "0123456789abcdef";
  for (int i = 0; i < SHA256_DIGEST_LENGTH; i++) {
    hashCode[2 * i] = hexChars[(unsigned int)hashBuf[i] >> 4];
    hashCode[2 * i + 1] = hexChars[(unsigned int)hashBuf[i] & 0x0F];
  }
  return hashCode;
}

// hash a group of strings, run by a thread
void tryHashInGroup(std::string &pswd, const std::string &hashcode,
                    const std::vector<char> &dict, int32_t pswdLen,
                    size_t beginIdx, size_t endIdx) {
  for (size_t idx = beginIdx; idx < endIdx; ++idx) {
    std::string tryPswd(pswdLen, '\0');
    int32_t quotient = idx;
    for (int32_t pos = pswdLen - 1; pos >= 0; --pos) {
      tryPswd[pos] = dict[quotient % dict.size()];
      quotient = quotient / dict.size();
    }
    std::string encrypted = tryOneSHA256(tryPswd);
    ++counter;
    if (hashcode == encrypted) {
      pswd = std::string(tryPswd);
      hackFlag = true;
      break;
    }
    if (hackFlag) {
      break; // if one other thread succeeded, terminate.
    }
  }
  --aliveThrs;
}

int main(int agrc, char **argv) {
  if (agrc != 4) {
    std::cout
        << "Usage: ./decrypt-hash <threads> <passwordlength> <hashcode>\n";
    return EXIT_FAILURE;
  }
  // init
  auto start_time = std::chrono::steady_clock::now();
  int thrNum = std::stoi(argv[1]);
  int pswdLen = std::stoi(argv[2]);
  std::string hashcode(argv[3]);
  std::vector<char> dict = genDictionary();
  size_t totalSize = std::pow(dict.size(), pswdLen);
  size_t groupSize = totalSize / thrNum;
  std::string pswd; // placeholder for decrypted password

  // spawn threads
  for (size_t i = 0; i < thrNum; ++i) {
    ++aliveThrs;
    if (i == thrNum - 1) {
      std::thread(tryHashInGroup, std::ref(pswd), std::ref(hashcode),
                  std::ref(dict), pswdLen, i * groupSize, totalSize)
          .detach();
    } else {
      std::thread(tryHashInGroup, std::ref(pswd), std::ref(hashcode),
                  std::ref(dict), pswdLen, i * groupSize, (i + 1) * groupSize)
          .detach();
    }
  }

  // main thread wait and display
  std::mutex mtx;
  std::unique_lock<std::mutex> lck(mtx);
  std::condition_variable cv;
  progressbar bar;
  while (aliveThrs > 0) {
    bar.display(100 * counter / totalSize);          // update progress bar
    cv.wait_for(lck, std::chrono::milliseconds(50)); // update freq = 20Hz
  }
  bar.display(100 * counter / totalSize); // display final progress
  if (hackFlag) {
    std::cout << "\nPassword is [" << pswd << "]\n";
  } else {
    std::cout << "\nHack failed! Password not found\n";
  }

  // elapsed time
  auto end_time = std::chrono::steady_clock::now();
  auto elapsed_time =
      std::chrono::duration_cast<std::chrono::seconds>(end_time - start_time);
  std::cout << "Elapsed time: " << elapsed_time.count() << "s\n";

  // log
  std::ofstream f("log.txt", std::ios_base::app);
  if (f.is_open()) {
    f << argv[0] << " " << argv[1] << " " << argv[2] << " " << argv[3] << "\n";
    if (hackFlag) {
      f << "Password is [" << pswd << "]\n";
    } else {
      f << "Hack failed! Password not found\n";
    }
    f << "Elapsed time: " << elapsed_time.count() << "s\n\n";
  }

  return EXIT_SUCCESS;
}