#include <cmath>
#include <cstdlib>
#include <fstream>
#include <iostream>
#include <openssl/sha.h>
#include <string>
#include <thread>
#include <vector>

std::mutex mtx;
std::atomic<bool> encrytFlag(false);

std::vector<char> genDictionary() {
  std::vector<char> chars;
  for (char i = 'a'; i <= 'z'; ++i) {
    chars.push_back(i);
  }
  for (char i = 'A'; i <= 'Z'; ++i) {
    chars.push_back(i);
  }
  for (char i = '0'; i <= '9'; ++i) {
    chars.push_back(i);
  }
  return chars;
}

std::vector<unsigned char> tryOneSHA256(const std::string &pswd) {
  std::vector<unsigned char> hash(SHA256_DIGEST_LENGTH);
  SHA256((unsigned char *)pswd.data(), pswd.length(), hash.data());
  return hash;
}

void printHashcode(const std::vector<unsigned char> &encrypted) {
  for (size_t i = 0; i < encrypted.size(); ++i) {
    std::cout << std::hex << (int)encrypted[i];
  }
  std::cout << "\n";
}

void tryHashInGroup(std::string &pswd,
                    const std::vector<unsigned char> &hashcode,
                    const std::vector<char> &dict, int32_t pswdLen,
                    size_t beginIdx, size_t endIdx) {
  mtx.lock();
  std::cout << "thread()" << std::this_thread::get_id() << ") is working...\n";
  mtx.unlock();
  for (size_t idx = beginIdx; idx < endIdx; ++idx) {
    mtx.lock();
    std::cout << "thread()" << std::this_thread::get_id()
              << ") is working on idx(" << idx << ")\n";
    mtx.unlock();
    std::string tryPswd(pswdLen, '\0');
    int32_t quotient = idx;
    for (int32_t pos = pswdLen - 1; pos >= 0; --pos) {
      tryPswd[pos] = dict[quotient % dict.size()];
      quotient = quotient / dict.size();
    }
    std::vector<unsigned char> encrypted = tryOneSHA256(tryPswd);
    if (encrytFlag) {
      break;
    }
    if (hashcode == encrypted) {
      encrytFlag.store(true);
      pswd = std::string(tryPswd);
      std::cout << "thread()" << std::this_thread::get_id()
                << ") hack the password!\n";
      break;
    }
  }
}

int main(int agrc, char **argv) {
  if (agrc != 2) {
    std::cout << "Usage: ./decrypt-hash <threads>\n";
    return EXIT_FAILURE;
  }

  std::vector<unsigned char> hashcode = {
      0x3, 0x8, 0x0, 0x3, 0xb, 0x4, 0x7, 0x6, 0x0, 0x9, 0xa, 0x2, 0xa,
      0x4, 0x6, 0x4, 0x0, 0x5, 0x4, 0x6, 0x5, 0x9, 0xb, 0x1, 0x4, 0xa,
      0x0, 0xc, 0xd, 0xf, 0xb, 0xa, 0x9, 0x2, 0x8, 0x3, 0x0, 0xf, 0xb,
      0x4, 0x6, 0xe, 0xe, 0x7, 0x0, 0xc, 0x0, 0x3, 0xa, 0x3, 0x3, 0x6,
      0xd, 0x5, 0x5, 0x5, 0x4, 0xb, 0x9, 0xa, 0xc, 0xa, 0xd, 0x4};
  std::vector<char> dict = genDictionary();
  std::string pswd;

  int num = std::stoi(argv[1]);
  int pswdLen = 4;
  size_t group = 14776336 / num;

  std::vector<std::thread> thr_pool(num);
  for (int i = 0; i < thr_pool.size(); ++i) {
    thr_pool[i] =
        std::thread(tryHashInGroup, std::ref(pswd), std::ref(hashcode),
                    std::ref(dict), pswdLen, i * group, (i + 1) * group);
  }
  for (int i = 0; i < thr_pool.size(); ++i) {
    thr_pool[i].join();
  }
  std::cout << "password is " << pswd << "\n";
  return EXIT_SUCCESS;
}